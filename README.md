# Погодный API (FastAPI + Open‑Meteo + SQLite)

Асинхронный HTTP‑сервер на **FastAPI**, который:

- получает **текущую погоду** и **почасовой прогноз на сегодня** через **Open‑Meteo** (`https://api.open-meteo.com/v1/forecast`);
- хранит данные в **SQLite** (файл `weather.db`) с использованием **aiosqlite**;
- поддерживает **REST API** для получения погоды и управления списком городов;
- в фоне **обновляет прогноз каждые 15 минут** для всех добавленных городов.

---

## Содержание

- [Быстрый старт](#быстрый-старт)
- [Swagger-документация](#swagger-документация)
- [Хранение данных](#хранение-данных)
- [Фоновое обновление прогноза](#фоновое-обновление-прогноза)
- [REST API](#rest-api)
  - [`GET /weather/current`](#get-weathercurrent)
  - [`POST /cities`](#post-cities)
  - [`GET /cities`](#get-cities)
  - [`GET /weather/forecast`](#get-weatherforecast)
- [Примечания](#примечания)

---

## Быстрый старт

### Требования

- Python **3.10+**
- Установленные пакеты:
  - `fastapi`
  - `uvicorn`
  - `httpx`
  - `aiosqlite`
  - `pydantic`

Установка зависимостей:

```bash
pip install fastapi uvicorn httpx aiosqlite pydantic
```

### Запуск сервера

Запуск выполняется **строго так**, как требуется по заданию:

```bash
python3 script.py
```

После запуска сервер доступен по адресу:

- **http://127.0.0.1:8000**

> При первом запуске автоматически создастся файл базы данных `weather.db` (если его ещё нет).

---

## Swagger-документация

FastAPI автоматически генерирует документацию:

- **Swagger UI:** `http://127.0.0.1:8000/docs`
- **OpenAPI schema (JSON):** `http://127.0.0.1:8000/openapi.json`

В Swagger UI можно:
- посмотреть все эндпоинты;
- увидеть схемы входных/выходных данных (Pydantic models);
- выполнить запросы прямо из браузера.

---

## Хранение данных

Используется SQLite база в файле:

- `weather.db`

### Таблицы

#### `cities`
Список городов, для которых сервис хранит прогноз:

- `id` — PK
- `name` — уникальное название города
- `lat` — широта
- `lon` — долгота

#### `forecast_hourly`
Почасовой прогноз **на текущий день**:

- `city_id` — FK → `cities.id`
- `date` — дата прогноза (`YYYY-MM-DD`)
- `time` — дата+время часа (`YYYY-MM-DDTHH:MM`)
- `temp` — температура
- `humidity` — влажность
- `wind_speed` — скорость ветра
- `precipitation` — осадки (мм)
- `updated_at` — когда запись была обновлена (UTC)

Также создаётся индекс для ускорения выборок:

- `idx_forecast(city_id, date, time)`

> Включены внешние ключи: `PRAGMA foreign_keys = ON;`  
> Это нужно, чтобы работали ограничения `FOREIGN KEY` и (при удалении города) каскадное удаление связанных прогнозов.

---

## Фоновое обновление прогноза

После запуска приложения создаётся фоновая задача, которая в цикле:

1. читает все города из `cities`;
2. для каждого города запрашивает у Open‑Meteo почасовой прогноз на текущий день;
3. делает **upsert** (вставку/обновление) строк прогноза в `forecast_hourly`;
4. ждёт `update_timeout` минут (по умолчанию **15**) и повторяет.

### Важно

- Сразу после добавления города прогноз может отсутствовать до ближайшего обновления (до 15 минут).
- В процессе обновления для города удаляются старые записи, которые **не относятся к текущей дате**:
  - `DELETE FROM forecast_hourly WHERE city_id=? AND date<>?`

---

# REST API

## `GET /weather/current`

Получить **текущую** погоду по координатам.

### Параметры (Query)

- `lat` *(float)* — широта (**-90..90**) — обязательный
- `lon` *(float)* — долгота (**-180..180**) — обязательный

### Что возвращает

Модель ответа: `CurrentWeatherOut`

- `temp` — температура
- `wind_speed` — скорость ветра
- `pressure` — давление (MSL)
- `source_time` — время измерения/выдачи (по данным Open‑Meteo)
- `temp_unit`, `wind_unit`, `pressure_unit` — единицы измерения
- `timezone` — аббревиатура таймзоны, выбранной Open‑Meteo

### Пример

```bash
curl "http://127.0.0.1:8000/weather/current?lat=55.75&lon=37.62"
```

### Возможные ошибки

- `400` — некорректные координаты
- `502` — ошибка при запросе к Open‑Meteo

---

## `POST /cities`

Добавить город в список отслеживаемых.

### Тело запроса (JSON)

Модель запроса: `AddCityIn`

- `name` *(string)* — название города (не пустое, `1..100`) — обязательный
- `lat` *(float)* — широта (**-90..90**) — обязательный
- `lon` *(float)* — долгота (**-180..180**) — обязательный

> Название города дополнительно валидируется: нельзя строку из одних пробелов, пробелы по краям обрезаются.

### Что возвращает

Модель ответа: `CityOut` (`name`, `lat`, `lon`)

### Пример

```bash
curl -X POST "http://127.0.0.1:8000/cities" \
  -H "Content-Type: application/json" \
  -d '{"name":"Moscow","lat":55.75,"lon":37.62}'
```

### Возможные ошибки

- `400` — город с таким названием уже существует
- `422` — ошибка валидации тела запроса (Pydantic)

---

## `GET /cities`

Получить список всех городов, добавленных в `cities`.

### Что возвращает

Список `CityOut[]`, отсортированный по `name`.

### Пример

```bash
curl "http://127.0.0.1:8000/cities"
```

---

## `GET /weather/forecast`

Получить прогноз для города **на текущий день** в указанное время.

### Параметры (Query)

- `city` *(string)* — название города — обязательный
- `time` *(string)* — время в формате **HH:MM** (например `14:00`) — обязательный
- `fields` *(string, optional)* — список полей через запятую:  
  `temp,humidity,wind_speed,precipitation`

Если `fields` не указан — возвращаются **все** поля.

### Как выбирается час

Прогноз хранится **почасовой**. В `time` проверяется формат `HH:MM`, затем берётся только час `HH` и ищется запись:

- `time LIKE "{today}T{HH}%"`

То есть `14:37` и `14:00` попадут в один и тот же час `14`.

### Что возвращает

Модель ответа: `ForecastOut`

- `city` — город
- `date` — сегодняшняя дата (`YYYY-MM-DD`)
- `time` — найденное время (`YYYY-MM-DDTHH:MM`)
- `weather` — словарь с выбранными полями

### Примеры

Все поля:

```bash
curl "http://127.0.0.1:8000/weather/forecast?city=Moscow&time=14:00"
```

Только температура и ветер:

```bash
curl "http://127.0.0.1:8000/weather/forecast?city=Moscow&time=14:00&fields=temp,wind_speed"
```

### Возможные ошибки

- `400` — неверный формат времени или указаны неизвестные поля в `fields`
- `404` — город не найден в БД **или** прогноз на этот час ещё отсутствует
- `422` — ошибка валидации query-параметров

---

## Примечания

### 1) Проверка данных в SQLite вручную

Базу можно открыть стандартной утилитой:

```bash
sqlite3 weather.db
```

Примеры запросов:

```sql
SELECT * FROM cities;
SELECT * FROM forecast_hourly LIMIT 10;
```

### 2) Почему прогноз может отсутствовать сразу после добавления города

Фоновый апдейтер обновляет данные раз в `update_timeout` минут (**15**).  
Если вы только что добавили город, таблица `forecast_hourly` может быть пустой до ближайшего цикла обновления.
